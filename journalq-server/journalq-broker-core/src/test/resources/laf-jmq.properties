opts.memory=-Xms10G -Xmx10G -Xmn5g -server -XX:PermSize=128M -XX:+PrintGCDetails -Xloggc:/export/Logs/jmq.server/gc.log -Xss256K -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=70 -XX:+CMSParallelRemarkEnabled -XX:SoftRefLRUPolicyMSPerMB=0 -XX:CMSMaxAbortablePrecleanTime=100 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses -XX:+PrintGCTimeStamps
#缓存配置路径
#默认发送数据包超时时间，默认5秒
netty.server.sendTimeout=5000
#工作线程
netty.server.workerThreads=24
#回调线程，默认CPU个数
netty.server.callbackExecutorThreads=0
#选择器线程
netty.server.selectorThreads=8
#通道最大空闲时间(毫秒)
netty.server.channelMaxIdleTime=120000
#表示是否允许重用Socket所绑定的本地地址
netty.server.reuseAddress=true
#关闭时候，对未发送数据包等待时间(秒)，-1,0:禁用,丢弃未发送的数据包>0，等到指定时间，如果还未发送则丢弃
netty.server.soLinger=-1
#启用nagle算法，为真立即发送，否则得到确认或缓冲区满发送
netty.server.tcpNoDelay=true
#保持活动连接，定期心跳包
netty.server.keepAlive=true
#socket读超时时间(毫秒)
netty.server.soTimeout=2000
#socket缓冲区大小
netty.server.socketBufferSize=8192
#使用EPOLL，只支持Linux模式
netty.server.epoll=true
#最大单向请求并发数
netty.server.maxOneway=24
#最大异步请求数
netty.server.maxAsync=48
#服务IP
netty.server.ip=
#服务端口
netty.server.port=50088
#连接请求最大队列长度，如果队列满时收到连接指示，则拒绝该连接。
netty.server.backlog=65536

#默认发送数据包超时时间，默认5秒
netty.client.sendTimeout=5000
#工作线程
netty.client.workerThreads=4
#回调线程，默认CPU个数
netty.client.callbackExecutorThreads=0
#选择器线程
netty.client.selectorThreads=1
#通道最大空闲时间(毫秒)
netty.client.channelMaxIdleTime=120000
#表示是否允许重用Socket所绑定的本地地址
netty.client.reuseAddress=true
#关闭时候，对未发送数据包等待时间(秒)，-1,0:禁用,丢弃未发送的数据包>0，等到指定时间，如果还未发送则丢弃
netty.client.soLinger=-1
#启用nagle算法，为真立即发送，否则得到确认或缓冲区满发送
netty.client.tcpNoDelay=true
#保持活动连接，定期心跳包
netty.client.keepAlive=true
#socket读超时时间(毫秒)
netty.client.soTimeout=2000
#socket缓冲区大小
netty.client.socketBufferSize=8192
#使用EPOLL，只支持Linux模式
netty.client.epoll=true
#最大单向请求并发数
netty.client.maxOneway=256
#最大异步请求数
netty.client.maxAsync=128
#连接超时(毫秒)
netty.client.connectionTimeout=5000


#复制服务重启延迟时间
ha.restartDelay=2000
#每次同步最大数据(默认4M）
ha.blockSize=4194304
#复制超时时间
ha.timeout=2000
#
ha.insyncCount=1
#
ha.insyncSize=41943040

#消费消息处理器线程数(默认为32+CPU个数*4）
broker.getThreads=0
#消费消息处理器线程队列容量
broker.getQueueCapacity=100000
#生产消息处理器线程数(默认为32+CPU个数*4）
broker.putThreads=0
#生产消息处理器线程队列容量
broker.putQueueCapacity=100000
#管理命令处理器线程数
broker.adminThreads=8
#默认应答超时时间(默认5分钟)
broker.ackTimeout=300000
#默认消费批量大小(默认10条)
broker.batchSize=10
#检查应答超时时间间隔(默认30秒）
broker.checkAckExpireInterval=30000
#检查事务超时时间间隔
broker.checkTransactionExpireInterval=1000
#性能统计切片时间间隔
broker.perfStatInterval=60000
#角色决策者
broker.roleDecider=fix
#兼容协议,逗号分割
broker.protocols=jmq,octopus,kafka
#连续出错次数
broker.consumerContinueErrs=3
#连续出错暂停消费时间ms
broker.consumerContinueErrPauseInterval=5000
#push模式开关
broker.pushMode=false
#push模式，队列poll超时时间 ms
broker.pusherPollTimeout=100
#push模式过期检查时间间隔 ms
broker.checkBlockExpireInterval=10000
#是否使用新的GetClusterAck机制
broker.newGetClusterAckEnabled=false
broker.tokenPrefix=${jmq_token_prefix}
#是否需要开启异地多活机制
broker.multiDataCenterEnabled=false

#重试数据队列大小
retry.queueSize=100
#获取重试批量大小
retry.fetchSize=20
#获取重试数据的线程数
retry.fetchThreads=5
#获取重试数据的时间间隔（毫秒）
retry.fetchInterval=5000
#最大重试次数(无限制)
retry.maxRetrys=0
#最大重试间隔(默认5分钟)
retry.maxRetryDelay=300000
#重试间隔
retry.retryDelay=5000
#指数增加间隔时间
retry.useExponentialBackOff=true
#指数系数
retry.backOffMultiplier=2.0
#过期时间（默认3天）
retry.expireTime=259200000
#重试表数量
retry.tables=20
#重试SAF服务端口
retry.safPort=20880
#特定时间内重试次数
retry.limitTimes=5
#重试次数统计时间间隔
retry.statTimeWindowSize=10000
#直连重试地址
retry.fixAddress=${retry_fix_ddress}
#RedisDBRetryManager检查程序的线程数
retry.redisRetryCheckThreads=10
#重试拉取速度限制，1/n
retry.limitSpeed=20
#远程拉取重试总数
retry.remoteLoadRetryCount=true

#存储路径
store.path=${store_path}
#日志文件大小(128M)
store.journal.fileSize=134217728
#队列文件大小(655360条)
store.queue.fileSize=14417920
#日志文件同步刷盘
store.journal.flushPolicy.sync=false
#日志文件刷盘超时时间
store.journal.flushPolicy.syncTimeout=5000
store.journal.flushPolicy.flushInterval=1
store.journal.flushPolicy.dataSize=512000
#队列同步刷盘
store.queue.flushPolicy.sync=false
#队列刷盘时间间隔
store.queue.flushPolicy.flushInterval=60000
#队列刷盘数据大小
store.queue.flushPolicy.dataSize=8192
#清理文件间隔
store.cleanInterval=10000
#刷盘超时时间
store.flushTimeout=2000
#删除文件间隔
store.deleteFilesInterval=100
#删除文件时刻(2点钟)
store.deleteTime=2
#文件保留时间(2天)
store.fileReserveTime=3600000
#最大磁盘空间使用比率
store.maxDiskSpaceUsage=75
#最大磁盘空间，为0根据当前磁盘和最大磁盘空间计算出来
store.maxDiskSpace=0
#最大消息大小(默认2M)
store.maxMessageSize=2097152
#最大批量数量
store.maxBatchSize=100
#缓冲池大小
store.bufferPoolSize=${store_bufferPoolSize}
#消息等待写入队列大小
store.writeQueueSize=50000
#消息等待写入队列使用到RingBuffer是否立即释放内存
store.writeQueueReleaseMemoryAtOnce=true
#消息入队超时时间
store.writeEnqueueTimeout=100
#日志刷盘队列大小
store.commitQueueSize=8192
#派发队列大小
store.dispatchQueueSize=40000
#默认队列数
store.defaultQueues=5
#恢复的时候校验和
store.checksumOnRecover=true
#忽略journal错误
store.ignoreJournalError=false
#日志的内存大小(20G)
store.journalCacheSize=536870912
#队列的内存大小(10G)
store.queueCacheSize=536870912
#日志suffix
store.journalSuffix=journal
#队列suffix
store.queueSuffix=queue

hbase.poolSize=${hbase_poolSize}

ump.system.key=jmq-server
ump.jvm.key=jmq-server.jvm
#延迟调度线程数
delay.threads=5